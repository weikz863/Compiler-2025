#pragma once

#ifndef _PARSER_HPP_
#define _PARSER_HPP_

#include <memory>
#include <vector>
#include <set>
#include <optional>
#include "lexer.hpp"
#include "parse_rules.hpp"

class ParsingState {
 public:
  int nonterminal_type;
  std::size_t production_index;
  std::size_t position_in_production;
  std::size_t start_token_index;
  bool operator == (const ParsingState &) const;
  bool operator < (const ParsingState &) const;
};

// generated by copilot
class ParseError : public std::runtime_error {
 public:
  explicit ParseError(const std::string &message) : std::runtime_error(message) {}
};

class EarleyParser {
 public:
  EarleyParser(std::vector<Token> &&);
  EarleyParser(const EarleyParser &) = delete;
  EarleyParser(EarleyParser &&) = delete;
  EarleyParser& operator=(const EarleyParser &) = delete;
  EarleyParser& operator=(EarleyParser &&) = delete;
  ~EarleyParser() = default;
  bool accepts() const;

 private:
  const std::vector<Token> tokens;
  std::vector<std::vector<ParsingState>> table;

  bool is_finished(const ParsingState& state) const;
  bool is_empty_production(const ParsingState& state) const;
  Symbol next_element(const ParsingState& state) const;
  bool is_nonterminal(const Symbol& symbol) const;
  bool is_terminal(const Symbol& symbol) const;
  void add_to_set(ParsingState state, std::size_t chart_index);
  void predictor(const ParsingState& state, std::size_t chart_index);
  void scanner(const ParsingState& state, std::size_t chart_index);
  void completer(const ParsingState& state, std::size_t chart_index);
};

#endif