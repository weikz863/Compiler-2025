#pragma once

#ifndef _PARSE_RULES_HPP_
#define _PARSE_RULES_HPP_

#include <array>
#include <vector>
#include <variant>
#include "lexer.hpp"

enum class Nonterminal {
  ITEMS, 
  ITEM, 
  FUNCTION, 
    OPTIONAL_CONST, 
    FUNCTION_PARAMETERS,
    SELF_PARAM, 
    SHORTHAND_SELF,
    TYPED_SELF,
    FUNCTION_PARAM,
    FUNCTION_RETURN_TYPE,
      OPTIONAL_FUNCTION_PARAMETERS, 
      OPTIONAL_COMMA,
      COMMA_FUNCTION_PARAMS,
      OPTIONAL_FUNCTION_RETURN_TYPE,
      BLOCK_EXPRESSION_OR_SEMICOLON,
  STRUCT,
    STRUCT_FIELDS,
    STRUCT_FIELD,
      OPTIONAL_STRUCT_FIELDS,
      COMMA_STRUCT_FIELDS,
  ENUMERATION,
    ENUM_VARIANTS,
    ENUM_VARIANT,
      OPTIONAL_ENUM_VARIANTS,
      COMMA_ENUM_VARIANTS,
  CONSTANT_ITEM,
  TRAIT,
  IMPLEMENTATION,
    INHERENT_IMPL,
    TRAIT_IMPL,
  STATEMENT,
    LET_STATEMENT,
    EXPRESSION_STATEMENT,
  EXPRESSION,
    UNUSED1, // expression without block is removed; see comment in parse_rules.cpp
      BASIC_EXPRESSION,
        LITERAL_EXPRESSION,
        UNDERSCORE_EXPRESSION,
        GROUPED_EXPRESSION,
        ARRAY_EXPRESSION,
          OPTIONAL_ARRAY_ELEMENTS,
          ARRAY_ELEMENTS,
          COMMA_ARRAY_ELEMENTS,
        PATH_EXPRESSION,
        STRUCT_EXPRESSION,
          OPTIONAL_STRUCT_EXPR_FIELDS,
          STRUCT_EXPR_FIELDS,
          COMMA_STRUCT_EXPR_FIELDS,
          STRUCT_EXPR_FIELD,
      POSTFIX_EXPRESSION,
        METHOD_CALL_EXPRESSION,
          OPTIONAL_CALL_PARAMS,
          CALL_PARAMS,
          COMMA_CALL_PARAMS,
        FIELD_EXPRESSION,
        CALL_EXPRESSION,
        INDEX_EXPRESSION,
      UNARY_OPERATOR_EXPRESSION,
        BORROW_EXPRESSION,
        DEREFERENCE_EXPRESSION,
        NEGATION_EXPRESSION,
      TYPE_CAST_EXPRESSION,
      MULTIPLICATIVE_OPERATOR_EXPRESSION,
      ADDITIVE_OPERATOR_EXPRESSION,
      SHIFT_OPERATOR_EXPRESSION,
      AND_EXPRESSION,
      XOR_EXPRESSION,
      OR_EXPRESSION,
      COMPARISON_OPERATOR_EXPRESSION,
      LAZY_AND_EXPRESSION,
      LAZY_OR_EXPRESSION,
      ASSIGNMENT_EXPRESSION,
        SIMPLE_ASSIGNMENT_EXPRESSION,
        COMPOUND_ASSIGNMENT_EXPRESSION,
      FLOW_CONTROL_EXPRESSION,
        CONTINUE_EXPRESSION,
        BREAK_EXPRESSION,
        RETURN_EXPRESSION,
    EXPRESSION_WITH_BLOCK,
      BLOCK_EXPRESSION,
        STATEMENTS,
      LOOP_EXPRESSION,
        INFINITE_LOOP_EXPRESSION,
        PREDICATE_LOOP_EXPRESSION,
      IF_EXPRESSION,
        CONDITIONS,
  PATTERN,
    IDENTIFIER_PATTERN,
    WILDCARD_PATTERN,
    REFERENCE_PATTERN,
  TYPE,
    TYPE_PATH,
    REFERENCE_TYPE,
    ARRAY_TYPE,
    UNIT_TYPE,
  PATH_IN_EXPRESSION,
    PATH_EXPR_SEGMENT,
};

typedef std::variant<Token, Nonterminal> Symbol;
typedef std::vector<Symbol> Production;

static_assert(static_cast<int>(Nonterminal::PATH_EXPR_SEGMENT) + 1 == 97, "Ensure sizes match");
extern const std::array<std::vector<Production>, 97> parse_rules;

#endif