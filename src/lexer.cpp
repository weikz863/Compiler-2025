#include "lexer.hpp"
#include <stdexcept>
#include <cctype>
#include <set>
#include <array>

/* cannot be constexpr */
const std::set<std::string> keywords{
  "as", "break", "const", "continue", "crate", "else", "enum", "false", "fn", "for", "if", "impl", "in", "let",
  "loop", "match", "mod", "move", "mut", "pub", "ref", "return", "self", "Self", "static", "struct", "super",
  "trait", "true", "type", "unsafe", "use", "where", "while", "dyn"
};

constexpr std::array<const char*, 53> punctuations{
  "<<=", ">>=", "..=", "...",
  "<=", ">=", "==", "!=", 
  "&&", "||", 
  "<<", ">>",
  "+=", "-=", "*=", "/=", "%=", "^=", "&=", "|=",
  "..", "::", "->", "<-", "=>",
  "=", "<", ">", 
  "!", "~", "+", "-", "*", "/", "%", "^", "&", "|",
  "@", ".", ",", ";", ":", "#", "$", "?", "_",
  "{", "}", "[", "]", "(", ")",
};

/* generated by copilot */
std::pair<char, int> read_characters(const std::string_view &input) {
  if (input.empty()) {
    return {'\0', 0};
  }
  if (input[0] != '\\') {
    return {input[0], 1};
  }
  if (input.size() < 2) {
    throw LexerError("Invalid escape sequence"); // error message is generated by copilot
  }
  switch (input[1]) {
    case 'n':
      return {'\n', 2};
    case 'r':
      return {'\r', 2};
    case 't':
      return {'\t', 2};
    case '\\':
      return {'\\', 2};
    case '\'':
      return {'\'', 2};
    case '"':
      return {'"', 2};
    case '0':
      return {'\0', 2};
    case 'x':
      throw LexerError("Unsupported escape sequence"); // hex escape sequences are not supported currently
    default:
      throw LexerError("Invalid escape sequence");
  }
}

Token::Token() = default;
Token::Token(Type t) : type{t}, value{} {}
void Token::read_from(const std::string_view &input) {
  if (!value.empty()) {
    throw std::runtime_error("Token value already set"); // error message is generated by copilot
  }
  if (input.empty()) {
    throw std::runtime_error("Input is empty"); // error message is generated by copilot
  }
  switch (type) {
    case Type::Identifier:
    case Type::Keyword: {
      if (!std::isalpha(input[0])) {
        break;
      }
      for (char c: input) {
        if (std::isalnum(c) || c == '_') {
          value.push_back(c);
        } else {
          break;
        }
      }
      if (static_cast<bool>(keywords.count(value)) ^ (type == Type::Keyword)) {
        value.clear();
        break;
      }
      break;
    }
    case Type::CharLiteral:
    case Type::StringLiteral: {
      if ((type == Type::CharLiteral && input[0] != '\'') ||
          (type == Type::StringLiteral && input[0] != '"')) {
        break;
      }
      size_t i = 1;
      try {
        while (i < input.size()) {
          auto [c, len] = read_characters(input.substr(i));
          if (c == input[0] && len == 1) {
            break;
          }
          i += len;
        }
      } catch (const LexerError &) {
        break;
      }
      if (i >= input.size()) {
        break;
      }
      value = std::string(input.substr(0, i + 1));
      break;
    }
    case Type::IntegerLiteral: {
      if (!std::isdigit(input[0])) {
        break;
      }
      for (char c: input) {
        if (std::isalnum(c) || c == '_') {
          value.push_back(c);
        } else {
          break;
        }
      }
      break;
    }
    case Type::Punctuation: {
      for (const char *punct: punctuations) {
        if (input.starts_with(punct)) {
          value = punct;
          break;
        }
      }
      break;
    }
    case Type::Whitespace: { // added by copilot
      for (char c: input) {
        if (std::isspace(c)) {
          value.push_back(c);
        } else {
          break;
        }
      }
      break;
    }
    case Type::Comment: { // added by copilot
      if (input.starts_with("//")) {
        size_t i = 2;
        while (i < input.size() && input[i] != '\n') {
          ++i;
        }
        value = std::string(input.substr(0, i));
      } else if (input.starts_with("/*")) {
        size_t i = 2, nested = 1;
        while (i < input.size() && nested > 0) {
          if (i + 1 < input.size() && input[i] == '/' && input[i + 1] == '*') {
            ++nested;
            i += 2;
          } else if (i + 1 < input.size() && input[i] == '*' && input[i + 1] == '/') {
            --nested;
            i += 2;
          } else {
            ++i;
          }
        }
        if (nested != 0) {
          throw LexerError("Unterminated comment");
        }
        value = std::string(input.substr(0, i));
      }
      break;
    }
  }
}

static
Token try_lex(const std::string_view &input, Token::Type type) {
  Token token(type);
  token.read_from(input);
  return token;
}

/* generated by copilot */
std::vector<Token> lex(const std::string_view &input) {
  std::vector<Token> tokens;
  size_t i = 0;
  while (i < input.size()) {
    Token token;
    for (auto type: Token::types) {
      auto t = try_lex(input.substr(i), type);
      if (t.value.size() > token.value.size()) {
        token = t;
      }
    }
    if (token.value.empty()) {
      throw LexerError("Failed to lex token at position " + std::to_string(i));
    }
    i += token.value.size();
    if (token.type != Token::Type::Whitespace && token.type != Token::Type::Comment) {
      tokens.push_back(token);
    }
  }
  return tokens;
}