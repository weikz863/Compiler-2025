#include "lexer.hpp"
#include <stdexcept>
#include <cctype>
#include <set>
#include <array>

/* cannot be constexpr */
const std::set<std::string> keywords{
  "as", "break", "const", "continue", "crate", "else", "enum", "false", "fn", "for", "if", "impl", "in", "let",
  "loop", "match", "mod", "move", "mut", "pub", "ref", "return", "self", "Self", "static", "struct", "super",
  "trait", "true", "type", "unsafe", "use", "where", "while", "dyn"
};

constexpr std::array<const char*, 53> punctuations{
  "<<=", ">>=", "..=", "...",
  "<=", ">=", "==", "!=", 
  "&&", "||", 
  "<<", ">>",
  "+=", "-=", "*=", "/=", "%=", "^=", "&=", "|=",
  "..", "::", "->", "<-", "=>",
  "=", "<", ">", 
  "!", "~", "+", "-", "*", "/", "%", "^", "&", "|",
  "@", ".", ",", ";", ":", "#", "$", "?", "_",
  "{", "}", "[", "]", "(", ")",
};

/* generated by copilot */
class LexerError : public std::runtime_error {
 public:
  explicit LexerError(const std::string &message) : std::runtime_error(message) {}
};

/* generated by copilot */
std::pair<char, int> read_characters(const std::string_view &input) {
  if (input.empty()) {
    return {'\0', 0};
  }
  if (input[0] != '\\') {
    return {input[0], 1};
  }
  if (input.size() < 2) {
    throw LexerError("Invalid escape sequence"); // error message is generated by copilot
  }
  switch (input[1]) {
    case 'n':
      return {'\n', 2};
    case 'r':
      return {'\r', 2};
    case 't':
      return {'\t', 2};
    case '\\':
      return {'\\', 2};
    case '\'':
      return {'\'', 2};
    case '"':
      return {'"', 2};
    case '0':
      return {'\0', 2};
    case 'x':
      throw LexerError("Invalid escape sequence"); // hex escape sequences are not supported currently
    default:
      throw LexerError("Invalid escape sequence");
  }
}

class Token {
 public:
  enum class Type {
    Identifier,
    Keyword,
    CharLiteral,
    StringLiteral,
    IntegerLiteral,
    Punctuation,
  };
  Token() = default;
  Token(Type t) : type{t}, value{} {}
  void read_from(const std::string_view &input) {
    if (!value.empty()) {
      throw std::runtime_error("Token value already set"); // error message is generated by copilot
    }
    if (input.empty()) {
      throw std::runtime_error("Input is empty"); // error message is generated by copilot
    }
    switch (type) {
      case Type::Identifier:
      case Type::Keyword: {
        if (!std::isalpha(input[0])) {
          break;
        }
        for (char c: input) {
          if (std::isalnum(c) || c == '_') {
            value.push_back(c);
          } else {
            break;
          }
        }
        if (static_cast<bool>(keywords.count(value)) ^ (type == Type::Keyword)) {
          value.clear();
          break;
        }
        break;
      }
      case Type::CharLiteral:
      case Type::StringLiteral: {
        if ((type == Type::CharLiteral && input[0] != '\'') ||
            (type == Type::StringLiteral && input[0] != '"')) {
          break;
        }
        size_t i = 1;
        try {
          while (i < input.size()) {
            auto [c, len] = read_characters(input.substr(i));
            if (c == input[0] && len == 1) {
              break;
            }
            i += len;
          }
        } catch (const LexerError &) {
          break;
        }
        if (i >= input.size()) {
          break;
        }
        value = std::string(input.substr(0, i + 1));
        break;
      }
      case Type::IntegerLiteral: {
        if (!std::isdigit(value[0])) {
          break;
        }
        for (char c: input) {
          if (std::isalnum(c) || c == '_') {
            value.push_back(c);
          } else {
            break;
          }
        }
        break;
      }
      case Type::Punctuation: {
        for (const char *punct: punctuations) {
          if (input.starts_with(punct)) {
            value = punct;
            break;
          }
        }
        break;
      }
    }
  }
  Type type;
  constexpr static std::array<Type, 6> types = {
    Type::Identifier, Type::Keyword, Type::CharLiteral, Type::StringLiteral, Type::IntegerLiteral, Type::Punctuation
  };
  std::string value;
};

static
Token try_lex(const std::string_view &input, Token::Type type) {
  Token token(type);
  token.read_from(input);
  return token;
}

/* generated by copilot */
std::vector<Token> lex(const std::string_view &input) {
  std::vector<Token> tokens;
  size_t i = 0;
  while (i < input.size()) {
    if (std::isspace(input[i])) {
      ++i;
      continue;
    }
    tokens.push_back(Token());
    for (auto type: Token::types) {
      auto token = try_lex(input.substr(i), type);
      if (token.value.size() > tokens.back().value.size()) {
        tokens.back() = token;
      }
    }
    if (tokens.back().value.empty()) {
      throw LexerError("Failed to lex token at position " + std::to_string(i));
    }
    i += tokens.back().value.size();
  }
  return tokens;
}