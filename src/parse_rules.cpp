#include "parse_rules.hpp"
#include "lexer.hpp"
#include <vector>
#include <array>
#include <variant>

// all comments moved to the beginning
// TRAIT: associated items are parsed as normal items, compile-time item-type checks are done later
// IMPLEMENTATION: associated items are parsed as normal items

// expression structure changed to match Rust grammar more closely
// expression without block is removed, as it complicates the grammar and is not necessary
// block expressions are now zero or more statements plus an optional expression
// this allows for expressions like { let x: i32 = 5; x + 1 }

// some corner cases: {{2}} is parsed as a block expression containing a block expression containing a literal expression
// instead of a block expression containing a block-expression-statement containing a literal expression
// this is beause the block expression should evaluate to 2 instead of ()
// this means the rules with the optional expression should be preferred over the rules without the optional expression 

// if a block-expression is a block-expression-statement, it should evaluate to (), otherwise it's an error
// but this is uncheckable by CFG

// {{2} - 3} results in a parse error in standard Rust because the compiler expects {2} to be a statement
// it seems that testcases like this are inexistent 

// wildcard patterns and reference patterns are unused
// anyway, in Rust &mut x means (&mut) x, &(mut x) has another meaning
// this means &mut is preferred to & in reference patterns

// ambiguous grammar 1: method call vs field access and call
// parsed as method call per Rust grammar
// implementation: method call has higher precedence than field access and call

// ambiguous grammar 2: {{2} - 3}
// parsed as block expression containing a block expression-statement and a unary operator expression per Rust grammar
// but this is a parse error anyway
// however, {{2} + 3} is parsed as a block expression containing a binary operator expression 
// because unary + does not exist in Rust
// implementation: in block expressions, rules with more statements are preferred, then 
// if an expression-statement begins with a block expression, raise an error  

// ambiguous grammar 3: block expression-statement with semicolon vs block expression-statement without semicolon plus empty statement
// parsed as block expression-statement with semicolon per Rust grammar
// implementation: the rule with semicolon are preferred over the rule without semicolon

// generated by copilot
// left-recursive grammar is preferred
// epsilon production is allowed
// the first rule is the start symbol
// rules are tried in order, the first matching rule is used
const std::array<std::vector<Production>, 97> parse_rules {
  // 0. ITEMS -> ITEMS ITEM | epsilon
  std::vector<Production>{
    Production{ Symbol{Nonterminal::ITEMS}, Symbol{Nonterminal::ITEM} },
    Production{}
  },
  // 1. ITEM -> FUNCTION | STRUCT | ENUMERATION | CONSTANT_ITEM | TRAIT | IMPLEMENTATION
  std::vector<Production>{
    Production{ Symbol{Nonterminal::FUNCTION} },
    Production{ Symbol{Nonterminal::STRUCT} },
    Production{ Symbol{Nonterminal::ENUMERATION} },
    Production{ Symbol{Nonterminal::CONSTANT_ITEM} },
    Production{ Symbol{Nonterminal::TRAIT} },
    Production{ Symbol{Nonterminal::IMPLEMENTATION} },
  },
  // 2. FUNCTION -> OPTIONAL_CONST "fn" Identifier "(" OPTIONAL_FUNCTION_PARAMETERS ")"
  //             OPTIONAL_FUNCTION_RETURN_TYPE BLOCK_EXPRESSION_OR_SEMICOLON
  {
    { Nonterminal::OPTIONAL_CONST, Token(Token::Type::Keyword, "fn"), Token(Token::Type::Identifier),
      Nonterminal::OPTIONAL_FUNCTION_PARAMETERS,  Nonterminal::OPTIONAL_FUNCTION_RETURN_TYPE,
      Nonterminal::BLOCK_EXPRESSION_OR_SEMICOLON },
  },
  // 3. OPTIONAL_CONST -> "const" | epsilon
  {
    { Token(Token::Type::Keyword, "const") },
    { }
  },
  // 4. FUNCTION_PARAMETERS -> SELF_PARAM OPTIONAL_COMMA | 
  //                        FUNCTION_PARAM COMMA_FUNCTION_PARAMS OPTIONAL_COMMA |
  //                        SELF_PARAM "," FUNCTION_PARAM COMMA_FUNCTION_PARAMS OPTIONAL_COMMA
  {
    { Nonterminal::SELF_PARAM, Nonterminal::OPTIONAL_COMMA },
    { Nonterminal::FUNCTION_PARAM, Nonterminal::COMMA_FUNCTION_PARAMS, Nonterminal::OPTIONAL_COMMA },
    { Nonterminal::SELF_PARAM, Token(Token::Type::Punctuation, ","), Nonterminal::FUNCTION_PARAM,
      Nonterminal::COMMA_FUNCTION_PARAMS, Nonterminal::OPTIONAL_COMMA }
  },
  // 5. SELF_PARAM -> SHORTHAND_SELF | TYPED_SELF
  {
    { Nonterminal::SHORTHAND_SELF },
    { Nonterminal::TYPED_SELF }
  },
  // 6. SHORTHAND_SELF -> "&"? "mut"? "self"
  {
    { Token(Token::Type::Punctuation, "&"), Token(Token::Type::Keyword, "mut"), 
      Token(Token::Type::Keyword, "self") },
    { Token(Token::Type::Punctuation, "&"), Token(Token::Type::Keyword, "self") },
    { Token(Token::Type::Keyword, "mut"), Token(Token::Type::Keyword, "self") },
    { Token(Token::Type::Keyword, "self") }
  },
  // 7. TYPED_SELF -> "mut"?" "self" ":" TYPE
  {
    { Token(Token::Type::Keyword, "mut"), Token(Token::Type::Keyword, "self"), 
      Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE },
    { Token(Token::Type::Keyword, "self"), 
      Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE }
  },
  // 8. FUNCTION_PARAM -> PATTERN ":" TYPE
  {
    { Nonterminal::PATTERN, Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE }
  },
  // 9. FUNCTION_RETURN_TYPE -> "->" TYPE
  {
    { Token(Token::Type::Punctuation, "->"), Nonterminal::TYPE },
  },
  // 10. OPTIONAL_FUNCTION_PARAMETERS -> FUNCTION_PARAMETERS | epsilon
  {
    { Nonterminal::FUNCTION_PARAMETERS },
    { }
  },
  // 11. OPTIONAL_COMMA -> "," | epsilon
  {
    { Token(Token::Type::Punctuation, ",") },
    { }
  },
  // 12. COMMA_FUNCTION_PARAMS -> COMMA_FUNCTION_PARAMS "," FUNCTION_PARAM | epsilon
  {
    { Nonterminal::COMMA_FUNCTION_PARAMS, Token(Token::Type::Punctuation, ","), Nonterminal::FUNCTION_PARAM },
    { }
  },
  // 13. OPTIONAL_FUNCTION_RETURN_TYPE -> FUNCTION_RETURN_TYPE | epsilon
  {
    { Nonterminal::FUNCTION_RETURN_TYPE },
    { }
  },
  // 14. BLOCK_EXPRESSION_OR_SEMICOLON -> BLOCK_EXPRESSION | ";"
  {
    { Nonterminal::BLOCK_EXPRESSION },
    { Token(Token::Type::Punctuation, ";") }
  },
  // 15. STRUCT -> "struct" Identifier ("{" OPTIONAL_STRUCT_FIELDS "}" | ";")
  {
    { Token(Token::Type::Keyword, "struct"), Token(Token::Type::Identifier), 
      Token(Token::Type::Punctuation, "{"), Nonterminal::STRUCT_FIELDS, 
      Token(Token::Type::Punctuation, "}") },
    { Token(Token::Type::Keyword, "struct"), Token(Token::Type::Identifier), 
      Token(Token::Type::Punctuation, ";") }
  },
  // 16. STRUCT_FIELDS -> STRUCT_FIELD COMMA_STRUCT_FIELDS OPTIONAL_COMMA
  {
    { Nonterminal::STRUCT_FIELD, Nonterminal::COMMA_STRUCT_FIELDS, Nonterminal::OPTIONAL_COMMA },
  },
  // 17. STRUCT_FIELD -> Identifier ":" TYPE
  {
    { Token(Token::Type::Identifier), Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE }
  },
  // 18. OPTIONAL_STRUCT_FIELDS -> STRUCT_FIELDS | epsilon
  {
    { Nonterminal::STRUCT_FIELDS },
    { }
  },
  // 19. COMMA_STRUCT_FIELDS -> COMMA_STRUCT_FIELDS "," STRUCT_FIELD | epsilon
  {
    { Nonterminal::COMMA_STRUCT_FIELDS, Token(Token::Type::Punctuation, ","), Nonterminal::STRUCT_FIELD },
    { }
  },
  // 20. ENUMERATION -> "enum" Identifier "{" OPTIONAL_ENUM_VARIANTS "}" 
  {
    { Token(Token::Type::Keyword, "enum"), Token(Token::Type::Identifier), 
      Token(Token::Type::Punctuation, "{"), Nonterminal::OPTIONAL_ENUM_VARIANTS, 
      Token(Token::Type::Punctuation, "}") }
  },
  // 21. ENUM_VARIANTS -> ENUM_VARIANT COMMA_ENUM_VARIANTS OPTIONAL_COMMA
  {
    { Nonterminal::ENUM_VARIANT, Nonterminal::COMMA_ENUM_VARIANTS, Nonterminal::OPTIONAL_COMMA }
  },
  // 22. ENUM_VARIANT -> Identifier
  {
    { Token(Token::Type::Identifier) }
  },
  // 23. OPTIONAL_ENUM_VARIANTS -> ENUM_VARIANTS | epsilon
  {
    { Nonterminal::ENUM_VARIANTS },
    { }
  },
  // 24. COMMA_ENUM_VARIANTS -> COMMA_ENUM_VARIANTS "," ENUM_VARIANT | epsilon
  {
    { Nonterminal::COMMA_ENUM_VARIANTS, Token(Token::Type::Punctuation, ","), Nonterminal::ENUM_VARIANT },
    { }
  },
  // 25. CONSTANT_ITEM -> "const" Identifier ":" TYPE ("=" EXPRESSION)? ";"
  {
    { Token(Token::Type::Keyword, "const"), Token(Token::Type::Identifier), 
      Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE, 
      Token(Token::Type::Punctuation, "="), Nonterminal::EXPRESSION, 
      Token(Token::Type::Punctuation, ";") },
    { Token(Token::Type::Keyword, "const"), Token(Token::Type::Identifier), 
      Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE, 
      Token(Token::Type::Punctuation, ";") }
  },
  // 26. TRAIT -> "trait" Identifier "{" ITEMS "}"
  {
    { Token(Token::Type::Keyword, "trait"), Token(Token::Type::Identifier), 
      Token(Token::Type::Punctuation, "{"), Nonterminal::ITEMS, 
      Token(Token::Type::Punctuation, "}") }
  },
  // 27. IMPLEMENTATION -> INHERENT_IMPL | TRAIT_IMPL
  {
    { Nonterminal::INHERENT_IMPL },
    { Nonterminal::TRAIT_IMPL }
  },
  // 28. INHERENT_IMPL -> "impl" TYPE "{" ITEMS "}"
  {
    { Token(Token::Type::Keyword, "impl"), Nonterminal::TYPE, 
      Token(Token::Type::Punctuation, "{"), Nonterminal::ITEMS, 
      Token(Token::Type::Punctuation, "}") }
  },
  // 29. TRAIT_IMPL -> "impl" IDENTIFIER "for" TYPE "{" ITEMS "}"
  {
    { Token(Token::Type::Keyword, "impl"), Token(Token::Type::Identifier), 
      Token(Token::Type::Keyword, "for"), Nonterminal::TYPE, 
      Token(Token::Type::Punctuation, "{"), Nonterminal::ITEMS, 
      Token(Token::Type::Punctuation, "}") }
  },
  // 30. STATEMENT -> ";" | ITEM | LET_STATEMENT | EXPRESSION_STATEMENT
  {
    { Token(Token::Type::Punctuation, ";") },
    { Nonterminal::ITEM },
    { Nonterminal::LET_STATEMENT },
    { Nonterminal::EXPRESSION_STATEMENT }
  },
  // 31. LET_STATEMENT -> "let" PATTERN ":" TYPE ("=" EXPRESSION)? ";"
  {
    { Token(Token::Type::Keyword, "let"), Nonterminal::PATTERN, 
      Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE, 
      Token(Token::Type::Punctuation, "="), Nonterminal::EXPRESSION, 
      Token(Token::Type::Punctuation, ";") },
    { Token(Token::Type::Keyword, "let"), Nonterminal::PATTERN, 
      Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE, 
      Token(Token::Type::Punctuation, ";") }
  },
  // 32. EXPRESSION_STATEMENT -> EXPRESSION ";" | EXPRESSION_WITH_BLOCK
  {
    { Nonterminal::EXPRESSION, Token(Token::Type::Punctuation, ";") },
    { Nonterminal::EXPRESSION_WITH_BLOCK }
  },
  // 33. EXPRESSION -> FLOW_CONTROL_EXPRESSION
  {
    { Nonterminal::FLOW_CONTROL_EXPRESSION },
  },
  // 34. UNUSED1 -> [unused]
  {},
  // 35. BASIC_EXPRESSION -> LITERAL_EXPRESSION | UNDERSCORE_EXPRESSION | GROUPED_EXPRESSION | 
  //                       ARRAY_EXPRESSION | PATH_EXPRESSION | STRUCT_EXPRESSION | EXPRESSION_WITH_BLOCK
  {
    { Nonterminal::LITERAL_EXPRESSION },
    { Nonterminal::UNDERSCORE_EXPRESSION },
    { Nonterminal::GROUPED_EXPRESSION },
    { Nonterminal::ARRAY_EXPRESSION },
    { Nonterminal::PATH_EXPRESSION },
    { Nonterminal::STRUCT_EXPRESSION },
    { Nonterminal::EXPRESSION_WITH_BLOCK }
  },
  // 36. LITERAL_EXPRESSION -> CharLiteral | StringLiteral | IntegerLiteral | "true" | "false"
  {
    { Token(Token::Type::CharLiteral) },
    { Token(Token::Type::StringLiteral) },
    { Token(Token::Type::IntegerLiteral) },
    { Token(Token::Type::Keyword, "true") },
    { Token(Token::Type::Keyword, "false") }
  },
  // 37. UNDERSCORE_EXPRESSION -> "_"
  {
    { Token(Token::Type::Punctuation, "_") }
  },
  // 38. GROUPED_EXPRESSION -> "(" EXPRESSION ")"
  {
    { Token(Token::Type::Punctuation, "("), Nonterminal::EXPRESSION, 
      Token(Token::Type::Punctuation, ")") }
  },
  // 39. ARRAY_EXPRESSION -> "[" OPTIONAL_ARRAY_ELEMENTS "]"
  {
    { Token(Token::Type::Punctuation, "["), Nonterminal::OPTIONAL_ARRAY_ELEMENTS, 
      Token(Token::Type::Punctuation, "]") }
  },
  // 40. OPTIONAL_ARRAY_ELEMENTS -> ARRAY_ELEMENTS | epsilon
  {
    { Nonterminal::ARRAY_ELEMENTS },
    { }
  },
  // 41. ARRAY_ELEMENTS -> EXPRESSION COMMA_ARRAY_ELEMENTS OPTIONAL_COMMA | EXPRESSION ";" EXPRESSION
  {
    { Nonterminal::EXPRESSION, Nonterminal::COMMA_ARRAY_ELEMENTS, Nonterminal::OPTIONAL_COMMA },
    { Nonterminal::EXPRESSION, Token(Token::Type::Punctuation, ";"), Nonterminal::EXPRESSION }
  },
  // 42. COMMA_ARRAY_ELEMENTS -> COMMA_ARRAY_ELEMENTS "," EXPRESSION | epsilon
  {
    { Nonterminal::COMMA_ARRAY_ELEMENTS, Token(Token::Type::Punctuation, ","), Nonterminal::EXPRESSION },
    { }
  },
  // 43. PATH_EXPRESSION -> PATH_IN_EXPRESSION
  {
    { Nonterminal::PATH_IN_EXPRESSION }
  },
  // 44. STRUCT_EXPRESSION -> PATH_IN_EXPRESSION "{" OPTIONAL_STRUCT_EXPR_FIELDS "}"
  {
    { Nonterminal::PATH_IN_EXPRESSION, Token(Token::Type::Punctuation, "{"), 
      Nonterminal::OPTIONAL_STRUCT_EXPR_FIELDS, Token(Token::Type::Punctuation, "}") }
  },
  // 45. OPTIONAL_STRUCT_EXPR_FIELDS -> STRUCT_EXPR_FIELDS | epsilon
  {
    { Nonterminal::STRUCT_EXPR_FIELDS },
    { }
  },
  // 46. STRUCT_EXPR_FIELDS -> STRUCT_EXPR_FIELD COMMA_STRUCT_EXPR_FIELDS OPTIONAL_COMMA
  {
    { Nonterminal::STRUCT_EXPR_FIELD, Nonterminal::COMMA_STRUCT_EXPR_FIELDS, Nonterminal::OPTIONAL_COMMA }
  },
  // 47. COMMA_STRUCT_EXPR_FIELDS -> COMMA_STRUCT_EXPR_FIELDS "," STRUCT_EXPR_FIELD | epsilon
  {
    { Nonterminal::COMMA_STRUCT_EXPR_FIELDS, Token(Token::Type::Punctuation, ","), Nonterminal::STRUCT_EXPR_FIELD },
    { }
  },
  // 48. STRUCT_EXPR_FIELD -> Identifier ":" EXPRESSION
  {
    { Token(Token::Type::Identifier), Token(Token::Type::Punctuation, ":"), Nonterminal::EXPRESSION }
  },
  // 49. METHOD_CALL_EXPRESSION -> BASIC_EXPRESSION | METHOD_CALL_EXPRESSION "." PATH_EXPR_SEGMENT "(" OPTIONAL_CALL_PARAMS ")"
  {
    { Nonterminal::BASIC_EXPRESSION },
    { Nonterminal::METHOD_CALL_EXPRESSION, Token(Token::Type::Punctuation, "."), Nonterminal::PATH_EXPR_SEGMENT,
      Token(Token::Type::Punctuation, "("), Nonterminal::OPTIONAL_CALL_PARAMS, Token(Token::Type::Punctuation, ")") }
  },
  // 50. OPTIONAL_CALL_PARAMS -> CALL_PARAMS | epsilon
  {
    { Nonterminal::CALL_PARAMS },
    { }
  },
  // 51. CALL_PARAMS -> EXPRESSION COMMA_CALL_PARAMS OPTIONAL_COMMA
  {
    { Nonterminal::EXPRESSION, Nonterminal::COMMA_CALL_PARAMS, Nonterminal::OPTIONAL_COMMA }
  },
  // 52. COMMA_CALL_PARAMS -> COMMA_CALL_PARAMS "," EXPRESSION | epsilon
  {
    { Nonterminal::COMMA_CALL_PARAMS, Token(Token::Type::Punctuation, ","), Nonterminal::EXPRESSION },
    { }
  },
  // 53. FIELD_EXPRESSION -> METHOD_CALL_EXPRESSION | FIELD_EXPRESSION "." Identifier
  {
    { Nonterminal::METHOD_CALL_EXPRESSION },
    { Nonterminal::FIELD_EXPRESSION, Token(Token::Type::Punctuation, "."), Token(Token::Type::Identifier) }
  },
  // 54. PARANTHESIZED_EXPRESSION -> FIELD_EXPRESSION | CALL_EXPRESSION | INDEX_EXPRESSION
  {
    { Nonterminal::FIELD_EXPRESSION },
    { Nonterminal::CALL_EXPRESSION },
    { Nonterminal::INDEX_EXPRESSION }
  },
  // 55. CALL_EXPRESSION -> PARANTHESIZED_EXPRESSION "(" OPTIONAL_CALL_PARAMS ")"
  {
    { Nonterminal::PARANTHESIZED_EXPRESSION, Token(Token::Type::Punctuation, "("), 
      Nonterminal::OPTIONAL_CALL_PARAMS, Token(Token::Type::Punctuation, ")") }
  },
  // 56. INDEX_EXPRESSION -> PARANTHESIZED_EXPRESSION "[" EXPRESSION "]"
  {
    { Nonterminal::PARANTHESIZED_EXPRESSION, Token(Token::Type::Punctuation, "["), 
      Nonterminal::EXPRESSION, Token(Token::Type::Punctuation, "]") }
  },
  // 57. UNARY_OPERATOR_EXPRESSION -> PARANTHESIZED_EXPRESSION | BORROW_EXPRESSION | DEREFERENCE_EXPRESSION | NEGATION_EXPRESSION
  {
    { Nonterminal::PARANTHESIZED_EXPRESSION },
    { Nonterminal::BORROW_EXPRESSION },
    { Nonterminal::DEREFERENCE_EXPRESSION },
    { Nonterminal::NEGATION_EXPRESSION }
  },
  // 58. BORROW_EXPRESSION -> ("&" | "&&") "mut"? UNARY_OPERATOR_EXPRESSION
  {
    { Token(Token::Type::Punctuation, "&"), Token(Token::Type::Keyword, "mut"), Nonterminal::UNARY_OPERATOR_EXPRESSION },
    { Token(Token::Type::Punctuation, "&"), Nonterminal::UNARY_OPERATOR_EXPRESSION },
    { Token(Token::Type::Punctuation, "&&"), Token(Token::Type::Keyword, "mut"), Nonterminal::UNARY_OPERATOR_EXPRESSION },
    { Token(Token::Type::Punctuation, "&&"), Nonterminal::UNARY_OPERATOR_EXPRESSION }
  },
  // 59. DEREFERENCE_EXPRESSION -> "*" UNARY_OPERATOR_EXPRESSION
  {
    { Token(Token::Type::Punctuation, "*"), Nonterminal::UNARY_OPERATOR_EXPRESSION }
  },
  // 60. NEGATION_EXPRESSION -> ("!" | "-") UNARY_OPERATOR_EXPRESSION
  {
    { Token(Token::Type::Punctuation, "!"), Nonterminal::UNARY_OPERATOR_EXPRESSION },
    { Token(Token::Type::Punctuation, "-"), Nonterminal::UNARY_OPERATOR_EXPRESSION }
  },
  // 61. TYPE_CAST_EXPRESSION -> UNARY_OPERATOR_EXPRESSION | TYPE_CAST_EXPRESSION "as" TYPE
  {
    { Nonterminal::UNARY_OPERATOR_EXPRESSION },
    { Nonterminal::TYPE_CAST_EXPRESSION, Token(Token::Type::Keyword, "as"), Nonterminal::TYPE }
  },
  // 62. MULTIPLICATIVE_OPERATOR_EXPRESSION -> TYPE_CAST_EXPRESSION | MULTIPLICATIVE_OPERATOR_EXPRESSION ("*" | "/" | "%") TYPE_CAST_EXPRESSION
  {
    { Nonterminal::TYPE_CAST_EXPRESSION },
    { Nonterminal::MULTIPLICATIVE_OPERATOR_EXPRESSION, Token(Token::Type::Punctuation, "*"), Nonterminal::TYPE_CAST_EXPRESSION },
    { Nonterminal::MULTIPLICATIVE_OPERATOR_EXPRESSION, Token(Token::Type::Punctuation, "/"), Nonterminal::TYPE_CAST_EXPRESSION },
    { Nonterminal::MULTIPLICATIVE_OPERATOR_EXPRESSION, Token(Token::Type::Punctuation, "%"), Nonterminal::TYPE_CAST_EXPRESSION }
  },
  // 63. ADDITIVE_OPERATOR_EXPRESSION -> MULTIPLICATIVE_OPERATOR_EXPRESSION | ADDITIVE_OPERATOR_EXPRESSION ("+" | "-") MULTIPLICATIVE_OPERATOR_EXPRESSION
  {
    { Nonterminal::MULTIPLICATIVE_OPERATOR_EXPRESSION },
    { Nonterminal::ADDITIVE_OPERATOR_EXPRESSION, Token(Token::Type::Punctuation, "+"), Nonterminal::MULTIPLICATIVE_OPERATOR_EXPRESSION },
    { Nonterminal::ADDITIVE_OPERATOR_EXPRESSION, Token(Token::Type::Punctuation, "-"), Nonterminal::MULTIPLICATIVE_OPERATOR_EXPRESSION }
  },
  // 64. SHIFT_OPERATOR_EXPRESSION -> ADDITIVE_OPERATOR_EXPRESSION | SHIFT_OPERATOR_EXPRESSION ("<<" | ">>") ADDITIVE_OPERATOR_EXPRESSION
  {
    { Nonterminal::ADDITIVE_OPERATOR_EXPRESSION },
    { Nonterminal::SHIFT_OPERATOR_EXPRESSION, Token(Token::Type::Punctuation, "<<"), Nonterminal::ADDITIVE_OPERATOR_EXPRESSION },
    { Nonterminal::SHIFT_OPERATOR_EXPRESSION, Token(Token::Type::Punctuation, ">>"), Nonterminal::ADDITIVE_OPERATOR_EXPRESSION }
  },
  // 65. AND_EXPRESSION -> SHIFT_OPERATOR_EXPRESSION | AND_EXPRESSION "&" SHIFT_OPERATOR_EXPRESSION
  {
    { Nonterminal::SHIFT_OPERATOR_EXPRESSION },
    { Nonterminal::AND_EXPRESSION, Token(Token::Type::Punctuation, "&"), Nonterminal::SHIFT_OPERATOR_EXPRESSION }
  },
  // 66. XOR_EXPRESSION -> AND_EXPRESSION | XOR_EXPRESSION "^" AND_EXPRESSION
  {
    { Nonterminal::AND_EXPRESSION },
    { Nonterminal::XOR_EXPRESSION, Token(Token::Type::Punctuation, "^"), Nonterminal::AND_EXPRESSION }
  },
  // 67. OR_EXPRESSION -> XOR_EXPRESSION | OR_EXPRESSION "|" XOR_EXPRESSION
  {
    { Nonterminal::XOR_EXPRESSION },
    { Nonterminal::OR_EXPRESSION, Token(Token::Type::Punctuation, "|"), Nonterminal::XOR_EXPRESSION }
  },
  // 68. COMPARISON_OPERATOR_EXPRESSION -> OR_EXPRESSION | OR_EXPRESSION ("==" | "!=" | "<" | "<=" | ">" | ">=") OR_EXPRESSION
  {
    { Nonterminal::OR_EXPRESSION },
    { Nonterminal::OR_EXPRESSION, Token(Token::Type::Punctuation, "=="), Nonterminal::OR_EXPRESSION },
    { Nonterminal::OR_EXPRESSION, Token(Token::Type::Punctuation, "!="), Nonterminal::OR_EXPRESSION },
    { Nonterminal::OR_EXPRESSION, Token(Token::Type::Punctuation, "<"), Nonterminal::OR_EXPRESSION },
    { Nonterminal::OR_EXPRESSION, Token(Token::Type::Punctuation, "<="), Nonterminal::OR_EXPRESSION },
    { Nonterminal::OR_EXPRESSION, Token(Token::Type::Punctuation, ">"), Nonterminal::OR_EXPRESSION },
    { Nonterminal::OR_EXPRESSION, Token(Token::Type::Punctuation, ">="), Nonterminal::OR_EXPRESSION }
  },
  // 69. LAZY_AND_EXPRESSION -> COMPARISON_OPERATOR_EXPRESSION | LAZY_AND_EXPRESSION "&&" COMPARISON_OPERATOR_EXPRESSION
  {
    { Nonterminal::COMPARISON_OPERATOR_EXPRESSION },
    { Nonterminal::LAZY_AND_EXPRESSION, Token(Token::Type::Punctuation, "&&"), Nonterminal::COMPARISON_OPERATOR_EXPRESSION }
  },
  // 70. LAZY_OR_EXPRESSION -> LAZY_AND_EXPRESSION | LAZY_OR_EXPRESSION "||" LAZY_AND_EXPRESSION
  {
    { Nonterminal::LAZY_AND_EXPRESSION },
    { Nonterminal::LAZY_OR_EXPRESSION, Token(Token::Type::Punctuation, "||"), Nonterminal::LAZY_AND_EXPRESSION }
  },
  // 71. ASSIGNMENT_EXPRESSION -> LAZY_OR_EXPRESSION | SIMPLE_ASSIGNMENT_EXPRESSION | COMPOUND_ASSIGNMENT_EXPRESSION
  {
    { Nonterminal::LAZY_OR_EXPRESSION },
    { Nonterminal::SIMPLE_ASSIGNMENT_EXPRESSION },
    { Nonterminal::COMPOUND_ASSIGNMENT_EXPRESSION }
  },
  // 72. SIMPLE_ASSIGNMENT_EXPRESSION -> LAZY_OR_EXPRESSION "=" ASSIGNMENT_EXPRESSION
  {
    { Nonterminal::LAZY_OR_EXPRESSION, Token(Token::Type::Punctuation, "="), Nonterminal::ASSIGNMENT_EXPRESSION }
  },
  // 73. COMPOUND_ASSIGNMENT_EXPRESSION -> LAZY_OR_EXPRESSION ("+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=") ASSIGNMENT_EXPRESSION
  {
    { Nonterminal::LAZY_OR_EXPRESSION, Token(Token::Type::Punctuation, "+="), Nonterminal::ASSIGNMENT_EXPRESSION },
    { Nonterminal::LAZY_OR_EXPRESSION, Token(Token::Type::Punctuation, "-="), Nonterminal::ASSIGNMENT_EXPRESSION },
    { Nonterminal::LAZY_OR_EXPRESSION, Token(Token::Type::Punctuation, "*="), Nonterminal::ASSIGNMENT_EXPRESSION },
    { Nonterminal::LAZY_OR_EXPRESSION, Token(Token::Type::Punctuation, "/="), Nonterminal::ASSIGNMENT_EXPRESSION },
    { Nonterminal::LAZY_OR_EXPRESSION, Token(Token::Type::Punctuation, "%="), Nonterminal::ASSIGNMENT_EXPRESSION },
    { Nonterminal::LAZY_OR_EXPRESSION, Token(Token::Type::Punctuation, "&="), Nonterminal::ASSIGNMENT_EXPRESSION },
    { Nonterminal::LAZY_OR_EXPRESSION, Token(Token::Type::Punctuation, "|="), Nonterminal::ASSIGNMENT_EXPRESSION },
    { Nonterminal::LAZY_OR_EXPRESSION, Token(Token::Type::Punctuation, "^="), Nonterminal::ASSIGNMENT_EXPRESSION },
    { Nonterminal::LAZY_OR_EXPRESSION, Token(Token::Type::Punctuation, "<<="), Nonterminal::ASSIGNMENT_EXPRESSION },
    { Nonterminal::LAZY_OR_EXPRESSION, Token(Token::Type::Punctuation, ">>="), Nonterminal::ASSIGNMENT_EXPRESSION }
  },
  // 74. FLOW_CONTROL_EXPRESSION -> ASSIGNMENT_EXPRESSION | CONTINUE_EXPRESSION | BREAK_EXPRESSION | RETURN_EXPRESSION
  {
    { Nonterminal::ASSIGNMENT_EXPRESSION },
    { Nonterminal::CONTINUE_EXPRESSION },
    { Nonterminal::BREAK_EXPRESSION },
    { Nonterminal::RETURN_EXPRESSION }
  },
  // 75. CONTINUE_EXPRESSION -> "continue"
  {
    { Token(Token::Type::Keyword, "continue") }
  },
  // 76. BREAK_EXPRESSION -> "break" FLOW_CONTROL_EXPRESSION?
  {
    { Token(Token::Type::Keyword, "break"), Nonterminal::FLOW_CONTROL_EXPRESSION },
    { Token(Token::Type::Keyword, "break") }
  },
  // 77. RETURN_EXPRESSION -> "return" FLOW_CONTROL_EXPRESSION?
  {
    { Token(Token::Type::Keyword, "return"), Nonterminal::FLOW_CONTROL_EXPRESSION },
    { Token(Token::Type::Keyword, "return") }
  },
  // 78. EXPRESSION_WITH_BLOCK -> BLOCK_EXPRESSION | LOOP_EXPRESSION | IF_EXPRESSION
  {
    { Nonterminal::BLOCK_EXPRESSION },
    { Nonterminal::LOOP_EXPRESSION },
    { Nonterminal::IF_EXPRESSION }
  },
  // 79. BLOCK_EXPRESSION -> "{" STATEMENTS EXPRESSION? "}"
  {
    { Token(Token::Type::Punctuation, "{"), Nonterminal::STATEMENTS, Nonterminal::EXPRESSION, 
      Token(Token::Type::Punctuation, "}") },
    { Token(Token::Type::Punctuation, "{"), Nonterminal::STATEMENTS, 
      Token(Token::Type::Punctuation, "}") }
  },
  // 80. STATEMENTS -> STATEMENTS STATEMENT | epsilon
  {
    { Nonterminal::STATEMENTS, Nonterminal::STATEMENT },
    { }
  },
  // 81. LOOP_EXPRESSION -> INFINITE_LOOP_EXPRESSION | PREDICATE_LOOP_EXPRESSION
  {
    { Nonterminal::INFINITE_LOOP_EXPRESSION },
    { Nonterminal::PREDICATE_LOOP_EXPRESSION }
  },
  // 82. INFINITE_LOOP_EXPRESSION -> "loop" BLOCK_EXPRESSION
  {
    { Token(Token::Type::Keyword, "loop"), Nonterminal::BLOCK_EXPRESSION }
  },
  // 83. PREDICATE_LOOP_EXPRESSION -> "while" CONDITIONS BLOCK_EXPRESSION
  {
    { Token(Token::Type::Keyword, "while"), Nonterminal::CONDITIONS, Nonterminal::BLOCK_EXPRESSION }
  },
  // 84. IF_EXPRESSION -> "if" CONDITIONS BLOCK_EXPRESSION ("else" IF_EXPRESSION | "else" BLOCK_EXPRESSION)?
  {
    { Token(Token::Type::Keyword, "if"), Nonterminal::CONDITIONS, Nonterminal::BLOCK_EXPRESSION,
      Token(Token::Type::Keyword, "else"), Nonterminal::IF_EXPRESSION },
    { Token(Token::Type::Keyword, "if"), Nonterminal::CONDITIONS, Nonterminal::BLOCK_EXPRESSION,
      Token(Token::Type::Keyword, "else"), Nonterminal::BLOCK_EXPRESSION },
    { Token(Token::Type::Keyword, "if"), Nonterminal::CONDITIONS, Nonterminal::BLOCK_EXPRESSION }
  },
  // 85. CONDITIONS -> "(" EXPRESSION ")"
  {
    { Token(Token::Type::Punctuation, "("), Nonterminal::EXPRESSION, 
      Token(Token::Type::Punctuation, ")") }
  },
  // 86. PATTERN -> IDENTIFIER_PATTERN | WILDCARD_PATTERN | REFERENCE_PATTERN
  {
    { Nonterminal::IDENTIFIER_PATTERN },
    { Nonterminal::WILDCARD_PATTERN },
    { Nonterminal::REFERENCE_PATTERN }
  },
  // 87. IDENTIFIER_PATTERN -> "ref"? "mut"? Identifier
  {
    { Token(Token::Type::Keyword, "ref"), Token(Token::Type::Keyword, "mut"), 
      Token(Token::Type::Identifier) },
    { Token(Token::Type::Keyword, "ref"), Token(Token::Type::Identifier) },
    { Token(Token::Type::Keyword, "mut"), Token(Token::Type::Identifier) },
    { Token(Token::Type::Identifier) }
  },
  // 88. WILDCARD_PATTERN -> "_"
  {
    { Token(Token::Type::Punctuation, "_") }
  },
  // 89. REFERENCE_PATTERN -> ("&" | "&&") "mut"? PATTERN
  {
    { Token(Token::Type::Punctuation, "&"), Token(Token::Type::Keyword, "mut"), Nonterminal::PATTERN },
    { Token(Token::Type::Punctuation, "&"), Nonterminal::PATTERN },
    { Token(Token::Type::Punctuation, "&&"), Token(Token::Type::Keyword, "mut"), Nonterminal::PATTERN },
    { Token(Token::Type::Punctuation, "&&"), Nonterminal::PATTERN }
  },
  // 90. TYPE -> TYPE_PATH | REFERENCE_TYPE | ARRAY_TYPE | UNIT_TYPE
  {
    { Nonterminal::TYPE_PATH },
    { Nonterminal::REFERENCE_TYPE },
    { Nonterminal::ARRAY_TYPE },
    { Nonterminal::UNIT_TYPE }
  },
  // 91. TYPE_PATH -> PATH_EXPR_SEGMENT
  {
    { Nonterminal::PATH_EXPR_SEGMENT }
  },
  // 92. REFERENCE_TYPE -> "&" "mut"? TYPE
  {
    { Token(Token::Type::Punctuation, "&"), Token(Token::Type::Keyword, "mut"), Nonterminal::TYPE },
    { Token(Token::Type::Punctuation, "&"), Nonterminal::TYPE }
  },
  // 93. ARRAY_TYPE -> "[" TYPE ";" EXPRESSION "]"
  {
    { Token(Token::Type::Punctuation, "["), Nonterminal::TYPE, Token(Token::Type::Punctuation, ";"), 
      Nonterminal::EXPRESSION, Token(Token::Type::Punctuation, "]") }
  },
  // 94. UNIT_TYPE -> "(" ")"
  {
    { Token(Token::Type::Punctuation, "("), Token(Token::Type::Punctuation, ")") }
  },
  // 95. PATH_IN_EXPRESSION -> PATH_EXPR_SEGMENT ("::" PATH_EXPR_SEGMENT)?
  {
    { Nonterminal::PATH_EXPR_SEGMENT },
    { Nonterminal::PATH_EXPR_SEGMENT, Token(Token::Type::Punctuation, "::"), Nonterminal::PATH_EXPR_SEGMENT }
  },
  // 96. PATH_EXPR_SEGMENT -> Identifier | "Self" | "self"
  {
    { Token(Token::Type::Identifier) },
    { Token(Token::Type::Keyword, "Self") },
    { Token(Token::Type::Keyword, "self") }
  }
};