#include "parse_rules.hpp"
#include "lexer.hpp"
#include <vector>
#include <array>
#include <variant>

// all comments moved to the beginning
// TRAIT: associated items are parsed as normal items, compile-time item-type checks are done later
// IMPLEMENTATION: associated items are parsed as normal items

// ambiguous grammar 1: method call vs field access and call
// parsed as method call per Rust grammar

// generated by copilot
// left-recursive grammar is preferred
// epsilon production is allowed
// the first rule is the start symbol
// rules are tried in order, the first matching rule is used
const std::array<std::vector<std::vector<std::variant<Token, Nonterminal>>>, 1> parse_rules = {
  // 0. ITEMS -> ITEMS ITEM | epsilon
  {
    { Nonterminal::ITEMS, Nonterminal::ITEM },
    { }
  },
  // 1. ITEM -> FUNCTION | STRUCT | ENUMERATION | CONSTANT_ITEM | TRAIT | IMPLEMENTATION
  {
    { Nonterminal::FUNCTION },
    { Nonterminal::STRUCT },
    { Nonterminal::ENUMERATION },
    { Nonterminal::CONSTANT_ITEM },
    { Nonterminal::TRAIT },
    { Nonterminal::IMPLEMENTATION },
  },
  // 2. FUNCTION -> OPTIONAL_CONST "fn" Identifier "(" OPTIONAL_FUNCTION_PARAMETERS ")"
  //             OPTIONAL_FUNCTION_RETURN_TYPE "(" BLOCK_EXPRESSION_OR_COLON ")"
  {
    { Nonterminal::OPTIONAL_CONST, Token(Token::Type::Keyword, "fn"), Token(Token::Type::Identifier),
      Token(Token::Type::Punctuation, "("), Nonterminal::OPTIONAL_FUNCTION_PARAMETERS, 
      Token(Token::Type::Punctuation, ")"), Nonterminal::OPTIONAL_FUNCTION_RETURN_TYPE, 
      Token(Token::Type::Punctuation, "("), Nonterminal::BLOCK_EXPRESSION_OR_COLON, 
      Token(Token::Type::Punctuation, ")") }
  },
  // 3. OPTIONAL_CONST -> "const" | epsilon
  {
    { Token(Token::Type::Keyword, "const") },
    { }
  },
  // 4. FUNCTION_PARAMETERS -> SELF_PARAM OPTIONAL_COMMA | 
  //                        FUNCTION_PARAM COMMA_FUNCTION_PARAMS OPTIONAL_COMMA |
  //                        SELF_PARAM "," FUNCTION_PARAM COMMA_FUNCTION_PARAMETERS OPTIONAL_COMMA
  {
    { Nonterminal::SELF_PARAM, Nonterminal::OPTIONAL_COMMA },
    { Nonterminal::FUNCTION_PARAM, Nonterminal::COMMA_FUNCTION_PARAMETERS, Nonterminal::OPTIONAL_COMMA },
    { Nonterminal::SELF_PARAM, Token(Token::Type::Punctuation, ","), Nonterminal::FUNCTION_PARAM,
      Nonterminal::COMMA_FUNCTION_PARAMETERS, Nonterminal::OPTIONAL_COMMA }
  },
  // 5. SELF_PARAM -> SHORTHAND_SELF | TYPED_SELF
  {
    { Nonterminal::SHORTHAND_SELF },
    { Nonterminal::TYPED_SELF }
  },
  // 6. SHORTHAND_SELF -> "&"? "mut"? "self"
  {
    { Token(Token::Type::Punctuation, "&"), Token(Token::Type::Keyword, "mut"), 
      Token(Token::Type::Keyword, "self") },
    { Token(Token::Type::Punctuation, "&"), Token(Token::Type::Keyword, "self") },
    { Token(Token::Type::Keyword, "mut"), Token(Token::Type::Keyword, "self") },
    { Token(Token::Type::Keyword, "self") }
  },
  // 7. TYPED_SELF -> "mut"?" "self" ":" TYPE
  {
    { Token(Token::Type::Keyword, "mut"), Token(Token::Type::Keyword, "self"), 
      Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE },
    { Token(Token::Type::Keyword, "self"), 
      Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE }
  },
  // 8. FUNCTION_PARAM -> PATTERN ":" TYPE
  {
    { Nonterminal::PATTERN, Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE }
  },
  // 9. FUNCTION_RETURN_TYPE -> "->" TYPE
  {
    { Token(Token::Type::Punctuation, "->"), Nonterminal::TYPE },
  },
  // 10. OPTIONAL_FUNCTION_PARAMETERS -> FUNCTION_PARAMETERS | epsilon
  {
    { Nonterminal::FUNCTION_PARAMETERS },
    { }
  },
  // 11. OPTIONAL_COMMA -> "," | epsilon
  {
    { Token(Token::Type::Punctuation, ",") },
    { }
  },
  // 12. COMMA_FUNCTION_PARAMS -> COMMA_FUNCTION_PARAMS "," FUNCTION_PARAM | epsilon
  {
    { Nonterminal::COMMA_FUNCTION_PARAMS, Token(Token::Type::Punctuation, ","), Nonterminal::FUNCTION_PARAM },
    { }
  },
  // 13. OPTIONAL_FUNCTION_RETURN_TYPE -> FUNCTION_RETURN_TYPE | epsilon
  {
    { Nonterminal::FUNCTION_RETURN_TYPE },
    { }
  },
  // 14. BLOCK_EXPRESSION_OR_SEMICOLON -> BLOCK_EXPRESSION | ";"
  {
    { Nonterminal::BLOCK_EXPRESSION },
    { Token(Token::Type::Punctuation, ";") }
  },
  // 15. STRUCT -> "struct" Identifier ("{" OPTIONAL_STRUCT_FIELDS "}" | ";")
  {
    { Token(Token::Type::Keyword, "struct"), Token(Token::Type::Identifier), 
      Token(Token::Type::Punctuation, "{"), Nonterminal::STRUCT_FIELDS, 
      Token(Token::Type::Punctuation, "}") },
    { Token(Token::Type::Keyword, "struct"), Token(Token::Type::Identifier), 
      Token(Token::Type::Punctuation, ";") }
  },
  // 16. STRUCT_FIELDS -> STRUCT_FIELD COMMA_STRUCT_FIELDS OPTIONAL_COMMA
  {
    { Nonterminal::STRUCT_FIELD, Nonterminal::COMMA_STRUCT_FIELDS, Nonterminal::OPTIONAL_COMMA },
  },
  // 17. STRUCT_FIELD -> Identifier ":" TYPE
  {
    { Token(Token::Type::Identifier), Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE }
  },
  // 18. OPTIONAL_STRUCT_FIELDS -> STRUCT_FIELDS | epsilon
  {
    { Nonterminal::STRUCT_FIELDS },
    { }
  },
  // 19. COMMA_STRUCT_FIELDS -> COMMA_STRUCT_FIELDS "," STRUCT_FIELD | epsilon
  {
    { Nonterminal::COMMA_STRUCT_FIELDS, Token(Token::Type::Punctuation, ","), Nonterminal::STRUCT_FIELD },
    { }
  },
  // 20. ENUMERATION -> "enum" Identifier "{" OPTIONAL_ENUM_VARIANTS "}" 
  {
    { Token(Token::Type::Keyword, "enum"), Token(Token::Type::Identifier), 
      Token(Token::Type::Punctuation, "{"), Nonterminal::OPTIONAL_ENUM_VARIANTS, 
      Token(Token::Type::Punctuation, "}") }
  },
  // 21. ENUM_VARIANTS -> ENUM_VARIANT COMMA_ENUM_VARIANTS OPTIONAL_COMMA
  {
    { Nonterminal::ENUM_VARIANT, Nonterminal::COMMA_ENUM_VARIANTS, Nonterminal::OPTIONAL_COMMA }
  },
  // 22. ENUM_VARIANT -> Identifier
  {
    { Token(Token::Type::Identifier) }
  },
  // 23. OPTIONAL_ENUM_VARIANTS -> ENUM_VARIANTS | epsilon
  {
    { Nonterminal::ENUM_VARIANTS },
    { }
  },
  // 24. COMMA_ENUM_VARIANTS -> COMMA_ENUM_VARIANTS "," ENUM_VARIANT | epsilon
  {
    { Nonterminal::COMMA_ENUM_VARIANTS, Token(Token::Type::Punctuation, ","), Nonterminal::ENUM_VARIANT },
    { }
  },
  // 25. CONSTANT_ITEM -> "const" Identifier ":" TYPE ("=" EXPRESSION)? ";"
  {
    { Token(Token::Type::Keyword, "const"), Token(Token::Type::Identifier), 
      Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE, 
      Token(Token::Type::Punctuation, "="), Nonterminal::EXPRESSION, 
      Token(Token::Type::Punctuation, ";") },
    { Token(Token::Type::Keyword, "const"), Token(Token::Type::Identifier), 
      Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE, 
      Token(Token::Type::Punctuation, ";") }
  },
  // 26. TRAIT -> "trait" Identifier "{" ITEMS "}"
  {
    { Token(Token::Type::Keyword, "trait"), Token(Token::Type::Identifier), 
      Token(Token::Type::Punctuation, "{"), Nonterminal::ITEMS, 
      Token(Token::Type::Punctuation, "}") }
  },
  // 27. IMPLEMENTATION -> INHERENT_IMPL | TRAIT_IMPL
  {
    { Nonterminal::INHERENT_IMPL },
    { Nonterminal::TRAIT_IMPL }
  },
  // 28. INHERENT_IMPL -> "impl" TYPE "{" ITEMS "}"
  {
    { Token(Token::Type::Keyword, "impl"), Nonterminal::TYPE, 
      Token(Token::Type::Punctuation, "{"), Nonterminal::ITEMS, 
      Token(Token::Type::Punctuation, "}") }
  },
  // 29. TRAIT_IMPL -> "impl" IDENTIFIER "for" TYPE "{" ITEMS "}"
  {
    { Token(Token::Type::Keyword, "impl"), Token(Token::Type::Identifier), 
      Token(Token::Type::Keyword, "for"), Nonterminal::TYPE, 
      Token(Token::Type::Punctuation, "{"), Nonterminal::ITEMS, 
      Token(Token::Type::Punctuation, "}") }
  },
  // 30. STATEMENT -> ";" | ITEM | LET_STATEMENT | EXPRESSION_STATEMENT
  {
    { Token(Token::Type::Punctuation, ";") },
    { Nonterminal::ITEM },
    { Nonterminal::LET_STATEMENT },
    { Nonterminal::EXPRESSION_STATEMENT }
  },
  // 31. LET_STATEMENT -> "let" PATTERN ":" TYPE ("=" EXPRESSION)? ";"
  {
    { Token(Token::Type::Keyword, "let"), Nonterminal::PATTERN, 
      Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE, 
      Token(Token::Type::Punctuation, "="), Nonterminal::EXPRESSION, 
      Token(Token::Type::Punctuation, ";") },
    { Token(Token::Type::Keyword, "let"), Nonterminal::PATTERN, 
      Token(Token::Type::Punctuation, ":"), Nonterminal::TYPE, 
      Token(Token::Type::Punctuation, ";") }
  },
  // 32. EXPRESSION_STATEMENT -> EXPRESSION_WITHOUT_BLOCK ";" | EXPRESSION_WITH_BLOCK ";"?
  {
    { Nonterminal::EXPRESSION_WITHOUT_BLOCK, Token(Token::Type::Punctuation, ";") },
    { Nonterminal::EXPRESSION_WITH_BLOCK, Token(Token::Type::Punctuation, ";") },
    { Nonterminal::EXPRESSION_WITH_BLOCK }
  },
  // 33. EXPRESSION -> EXPRESSION_WITHOUT_BLOCK | EXPRESSION_WITH_BLOCK
  {
    { Nonterminal::EXPRESSION_WITHOUT_BLOCK },
    { Nonterminal::EXPRESSION_WITH_BLOCK }
  },
  // 34. EXPRESSION_WITHOUT_BLOCK -> FLOW_CONTROL_EXPRESSION
  {
    { Nonterminal::FLOW_CONTROL_EXPRESSION },
  },
  // 35. BASIC_EXPRESSION -> LITERAL_EXPRESSION | UNDERSCORE_EXPRESSION | GROUPED_EXPRESSION | 
  //                       ARRAY_EXPRESSION | PATH_EXPRESSION | STRUCT_EXPRESSION
  {
    { Nonterminal::LITERAL_EXPRESSION },
    { Nonterminal::UNDERSCORE_EXPRESSION },
    { Nonterminal::GROUPED_EXPRESSION },
    { Nonterminal::ARRAY_EXPRESSION },
    { Nonterminal::PATH_EXPRESSION },
    { Nonterminal::STRUCT_EXPRESSION }
  },
  // 36. LITERAL_EXPRESSION -> CharLiteral | StringLiteral | IntegerLiteral | "true" | "false"
  {
    { Token(Token::Type::CharLiteral) },
    { Token(Token::Type::StringLiteral) },
    { Token(Token::Type::IntegerLiteral) },
    { Token(Token::Type::Keyword, "true") },
    { Token(Token::Type::Keyword, "false") }
  },
  // 37. UNDERSCORE_EXPRESSION -> "_"
  {
    { Token(Token::Type::Punctuation, "_") }
  },
  // 38. GROUPED_EXPRESSION -> "(" EXPRESSION ")"
  {
    { Token(Token::Type::Punctuation, "("), Nonterminal::EXPRESSION, 
      Token(Token::Type::Punctuation, ")") }
  },
  // 39. ARRAY_EXPRESSION -> "[" OPTIONAL_ARRAY_ELEMENTS "]"
  {
    { Token(Token::Type::Punctuation, "["), Nonterminal::OPTIONAL_ARRAY_ELEMENTS, 
      Token(Token::Type::Punctuation, "]") }
  },
  // 40. OPTIONAL_ARRAY_ELEMENTS -> ARRAY_ELEMENTS | epsilon
  {
    { Nonterminal::ARRAY_ELEMENTS },
    { }
  },
  // 41. ARRAY_ELEMENTS -> EXPRESSION COMMA_ARRAY_ELEMENTS OPTIONAL_COMMA | EXPRESSION ";" EXPRESSION
  {
    { Nonterminal::EXPRESSION, Nonterminal::COMMA_ARRAY_ELEMENTS, Nonterminal::OPTIONAL_COMMA },
    { Nonterminal::EXPRESSION, Token(Token::Type::Punctuation, ";"), Nonterminal::EXPRESSION }
  },
  // 42. COMMA_ARRAY_ELEMENTS -> COMMA_ARRAY_ELEMENTS "," EXPRESSION | epsilon
  {
    { Nonterminal::COMMA_ARRAY_ELEMENTS, Token(Token::Type::Punctuation, ","), Nonterminal::EXPRESSION },
    { }
  },
  // 43. PATH_EXPRESSION -> PATH_IN_EXPRESSION
  {
    { Nonterminal::PATH_IN_EXPRESSION }
  },
  // 44. STRUCT_EXPRESSION -> PATH_IN_EXPRESSION "{" OPTIONAL_STRUCT_EXPR_FIELDS "}"
  {
    { Nonterminal::PATH_IN_EXPRESSION, Token(Token::Type::Punctuation, "{"), 
      Nonterminal::OPTIONAL_STRUCT_EXPR_FIELDS, Token(Token::Type::Punctuation, "}") }
  },
  // 45. OPTIONAL_STRUCT_EXPR_FIELDS -> STRUCT_EXPR_FIELDS | epsilon
  {
    { Nonterminal::STRUCT_EXPR_FIELDS },
    { }
  },
  // 46. STRUCT_EXPR_FIELDS -> STRUCT_EXPR_FIELD COMMA_STRUCT_EXPR_FIELDS OPTIONAL_COMMA
  {
    { Nonterminal::STRUCT_EXPR_FIELD, Nonterminal::COMMA_STRUCT_EXPR_FIELDS, Nonterminal::OPTIONAL_COMMA }
  },
  // 47. COMMA_STRUCT_EXPR_FIELDS -> COMMA_STRUCT_EXPR_FIELDS "," STRUCT_EXPR_FIELD | epsilon
  {
    { Nonterminal::COMMA_STRUCT_EXPR_FIELDS, Token(Token::Type::Punctuation, ","), Nonterminal::STRUCT_EXPR_FIELD },
    { }
  },
  // 48. STRUCT_EXPR_FIELD -> Identifier ":" EXPRESSION
  {
    { Token(Token::Type::Identifier), Token(Token::Type::Punctuation, ":"), Nonterminal::EXPRESSION }
  },
};